// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios14.3 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name PhysicsKit
import Foundation
@_exported import PhysicsKit
import SceneKit
import Swift
public class PKAction {
  public typealias SetupBlock = ((PhysicsKit.PKRigidBody) -> (Any?))
  public typealias ActionBlock = ((Foundation.TimeInterval, PhysicsKit.PKRigidBody, Any?) -> ())
  public var repeatCount: Swift.Int
  public init(rigidBody: PhysicsKit.PKRigidBody, duration: Foundation.TimeInterval, setup: PhysicsKit.PKAction.SetupBlock? = nil, action: PhysicsKit.PKAction.ActionBlock? = nil)
  public func run()
  public func stop()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PKDisplayLink {
  public var onTick: (() -> ())?
  public func start()
  public func stop()
  @objc deinit
}
public protocol PKPhysicsSceneUpdateDelegate : AnyObject {
  func physicsSceneWillIterativelyUpdate(_ physicsScene: PhysicsKit.PKPhysicsScene)
  func physicsSceneDidIterativelyUpdate(_ physicsScene: PhysicsKit.PKPhysicsScene)
  func physicsScene(_ physicsScene: PhysicsKit.PKPhysicsScene, willReactivelyUpdateNode node: SceneKit.SCNNode, attachedToRigidBody rigidBody: PhysicsKit.PKRigidBody)
  func physicsScene(_ physicsScene: PhysicsKit.PKPhysicsScene, didReactivelyUpdateNode node: SceneKit.SCNNode, attachedToRigidBody rigidBody: PhysicsKit.PKRigidBody)
}
public class PKCollisionShapeFromData : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(serializedData: Foundation.Data)
  @objc deinit
}
extension PKCollisionShape {
  public func serialize() -> Foundation.Data
}
public class PKCollisionShapeStaticPlane : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(direction: PhysicsKit.PKVector3 = PKVector3(0, 1, 0), transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  required public init(serializedData: Foundation.Data)
  @objc deinit
}
public class PKCollisionPair {
  weak public var rigidBodyA: PhysicsKit.PKRigidBody?
  final public let localPositionA: PhysicsKit.PKVector3
  weak public var rigidBodyB: PhysicsKit.PKRigidBody?
  final public let localPositionB: PhysicsKit.PKVector3
  public init(rigidBodyA: PhysicsKit.PKRigidBody, localPositionA: PhysicsKit.PKVector3, rigidBodyB: PhysicsKit.PKRigidBody, localPositionB: PhysicsKit.PKVector3)
  @objc deinit
}
extension PKVector3 {
  public var scnVector3: SceneKit.SCNVector3 {
    get
  }
  public init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float)
  public static var zero: PhysicsKit.PKVector3 {
    get
  }
  public static func vector(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> PhysicsKit.PKVector3
  public static func radians(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> PhysicsKit.PKVector3
  public static func degrees(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> PhysicsKit.PKVector3
  public static func radiansFromDegrees(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> PhysicsKit.PKVector3
  public static func degreesFromRadians(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> PhysicsKit.PKVector3
  public func toRadians() -> PhysicsKit.PKVector3
  public func toDegrees() -> PhysicsKit.PKVector3
}
extension PKVector4 {
  public init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float)
  public static func vector(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float) -> PhysicsKit.PKVector4
}
extension SCNVector3 {
  public var PKVector3: PhysicsKit.PKVector3 {
    get
  }
}
extension SCNVector4 {
  public var PKVector4: PhysicsKit.PKVector4 {
    get
  }
}
public enum PKRotationMetric {
  case radians
  case degrees
  public static func == (a: PhysicsKit.PKRotationMetric, b: PhysicsKit.PKRotationMetric) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension PKQuaternion {
  public var scnQuaternion: SceneKit.SCNQuaternion {
    get
  }
  public var direction: PhysicsKit.PKVector3 {
    get
  }
  public init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float)
  public static func quaternion(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float) -> PhysicsKit.PKQuaternion
  public static func euler(_ eulerX: Swift.Float, _ eulerY: Swift.Float, _ eulerZ: Swift.Float, _ metric: PhysicsKit.PKRotationMetric = .degrees) -> PhysicsKit.PKQuaternion
  public static var identity: PhysicsKit.PKQuaternion {
    get
  }
}
extension SCNVector4 {
  public var PKQuaternion: PhysicsKit.PKQuaternion {
    get
  }
}
extension PKMatrix4 {
  public var scnMatrix: SceneKit.SCNMatrix4 {
    get
  }
}
extension SCNMatrix4 {
  public var blMatrix: PhysicsKit.PKMatrix4 {
    get
  }
}
public protocol PKPhysicsWorldSimulationDelegate : AnyObject {
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, willSimulateAtTime time: Foundation.TimeInterval)
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, didSimulateAtTime time: Foundation.TimeInterval)
}
public class PKTriggerPair {
  final public let rigidBody: PhysicsKit.PKRigidBody
  final public let trigger: PhysicsKit.PKTrigger
  public init(rigidBody: PhysicsKit.PKRigidBody, trigger: PhysicsKit.PKTrigger)
  @objc deinit
}
extension PKAction {
  public static func orient(_ rigidBody: PhysicsKit.PKRigidBody, by delta: PhysicsKit.PKQuaternion, duration: Foundation.TimeInterval, longestArc: Swift.Bool = false) -> PhysicsKit.PKAction
  public static func orient(_ rigidBody: PhysicsKit.PKRigidBody, to end: PhysicsKit.PKQuaternion, duration: Foundation.TimeInterval, longestArc: Swift.Bool = false) -> PhysicsKit.PKAction
}
public protocol PKCollisionShape {
  var internalShape: PhysicsKit.PKBCollisionShape { get }
}
public class PKPhysicsScene {
  weak public var delegate: PhysicsKit.PKPhysicsSceneUpdateDelegate?
  public init(isMotionStateEnabled: Swift.Bool)
  public func attach(_ rigidBody: PhysicsKit.PKRigidBody, to node: SceneKit.SCNNode)
  public func detach(_ node: SceneKit.SCNNode)
  public func iterativelyOrientAllNodesToAttachedRigidBodies()
  @objc deinit
}
public class PKCollisionShapeGeometry : PhysicsKit.PKCollisionShape {
  public enum PKCollisionShapeGeometryType {
    case convex
    case concave
    public static func == (a: PhysicsKit.PKCollisionShapeGeometry.PKCollisionShapeGeometryType, b: PhysicsKit.PKCollisionShapeGeometry.PKCollisionShapeGeometryType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(geometry: PhysicsKit.PKGeometry, type: PhysicsKit.PKCollisionShapeGeometry.PKCollisionShapeGeometryType, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  @objc deinit
}
public class PKGeometry {
  final public let internalGeometry: PhysicsKit.PKBGeometry
  public init(scnGeometry: SceneKit.SCNGeometry)
  @objc deinit
}
public protocol PKPhysicsWorldCollisionDelegate : AnyObject {
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, collisionDidBeginAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKCollisionPair)
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, collisionDidContinueAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKCollisionPair)
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, collisionDidEndAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKCollisionPair)
}
public class PKCollisionShapeCapsule : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(radius: Swift.Float, height: Swift.Float, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  required public init(serializedData: Foundation.Data)
  @objc deinit
}
public class PKCollisionShapeBox : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(width: Swift.Float, height: Swift.Float, length: Swift.Float, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  public init(size: Swift.Float, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity())
  @objc deinit
}
public class PKCollisionShapeCylinder : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(radius: Swift.Float, height: Swift.Float, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  required public init(serializedData: Foundation.Data)
  @objc deinit
}
@objc public class PKRigidBody : PhysicsKit.PKBRigidBody {
  final public let uuid: Swift.String
  final public let type: PhysicsKit.PKRigidBodyType
  public init(type: PhysicsKit.PKRigidBodyType, shape: PhysicsKit.PKCollisionShape)
  @objc deinit
  @objc override dynamic public init(collisionShape: PhysicsKit.PKBCollisionShape, rigidBodyType: PhysicsKit.PKBRigidBodyType, mass: Swift.Float)
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class PKPhysicsWorld : PhysicsKit.PKBPhysicsWorld {
  weak public var simulationDelegate: PhysicsKit.PKPhysicsWorldSimulationDelegate?
  weak public var collisionDelegate: PhysicsKit.PKPhysicsWorldCollisionDelegate?
  weak public var triggerDelegate: PhysicsKit.PKPhysicsWorldTriggerDelegate?
  public var simulationTime: Swift.Double {
    get
    set
  }
  public func add(_ rigidBody: PhysicsKit.PKRigidBody)
  public func remove(_ rigidBody: PhysicsKit.PKRigidBody)
  public func add(_ trigger: PhysicsKit.PKTrigger)
  public func remove(_ trigger: PhysicsKit.PKTrigger)
  public func reset()
  public func rayCast(from: PhysicsKit.PKVector3, to: PhysicsKit.PKVector3) -> [PhysicsKit.PKRaycastResult]
  @objc override dynamic public func internalCollisionDidOccur(_ internalRigidBodyA: PhysicsKit.PKBRigidBody, localPositionA: PhysicsKit.PKVector3, internalRigidBodyB: PhysicsKit.PKBRigidBody, localPositionB: PhysicsKit.PKVector3)
  @objc deinit
  @objc override dynamic public init()
}
public class PKCollisionShapeSphere : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(radius: Swift.Float, transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  required public init(serializedData: Foundation.Data)
  @objc deinit
}
extension PKAction {
  public static func move(_ rigidBody: PhysicsKit.PKRigidBody, to end: PhysicsKit.PKVector3, duration: Foundation.TimeInterval) -> PhysicsKit.PKAction
  public static func move(_ rigidBody: PhysicsKit.PKRigidBody, by dist: PhysicsKit.PKVector3, duration: Foundation.TimeInterval) -> PhysicsKit.PKAction
  public static func move(_ rigidBody: PhysicsKit.PKRigidBody, byFunction distFunction: @escaping () -> (PhysicsKit.PKVector3)) -> PhysicsKit.PKAction
}
public protocol PKPhysicsWorldTriggerDelegate : AnyObject {
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, triggerDidBeginAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKTriggerPair)
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, triggerDidContinueAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKTriggerPair)
  func physicsWorld(_ physicsWorld: PhysicsKit.PKPhysicsWorld, triggerDidEndAtTime time: Foundation.TimeInterval, with collisionPair: PhysicsKit.PKTriggerPair)
}
public enum PKRigidBodyType : Swift.Equatable {
  case `static`
  case kinematic
  case dynamic(mass: Swift.Float)
  public static func == (lhs: PhysicsKit.PKRigidBodyType, rhs: PhysicsKit.PKRigidBodyType) -> Swift.Bool
}
extension PKRigidBodyType {
  public var mass: Swift.Float {
    get
  }
  public var isDynamic: Swift.Bool {
    get
  }
  public static var dynamic: PhysicsKit.PKRigidBodyType {
    get
  }
}
@objc public class PKTrigger : PhysicsKit.PKBPhysicsTrigger {
  final public let uuid: Swift.String
  public init(shape: PhysicsKit.PKCollisionShape)
  public func getCollidingRigidBodies() -> [PhysicsKit.PKRigidBody]
  @objc deinit
  @objc override dynamic public init(collisionShape: PhysicsKit.PKBCollisionShape)
  @objc override dynamic public init()
}
public class PKRaycastResult {
  weak public var rigidBody: PhysicsKit.PKRigidBody?
  final public let worldPosition: PhysicsKit.PKVector3
  final public let worldNormal: PhysicsKit.PKVector3
  public init(rigidBody: PhysicsKit.PKRigidBody, worldPosition: PhysicsKit.PKVector3, worldNormal: PhysicsKit.PKVector3)
  @objc deinit
}
public class PKCollisionShapeCompound : PhysicsKit.PKCollisionShape {
  final public let internalShape: PhysicsKit.PKBCollisionShape
  public init(collisionShapes: [PhysicsKit.PKCollisionShape], transform: PhysicsKit.PKMatrix4 = PKMatrix4MakeIdentity(), margin: Swift.Float = 0.04)
  @objc deinit
}
extension PhysicsKit.PKRotationMetric : Swift.Equatable {}
extension PhysicsKit.PKRotationMetric : Swift.Hashable {}
extension PhysicsKit.PKCollisionShapeGeometry.PKCollisionShapeGeometryType : Swift.Equatable {}
extension PhysicsKit.PKCollisionShapeGeometry.PKCollisionShapeGeometryType : Swift.Hashable {}
